.. _intro:

Introduction
=============

Creation of a separate implementation of the VAMDC-TAP node software in Java pursuied several goals:

*	Multiple implementations insure that standards are complete and contain no implementation-specific elements

*	Give end-users a choice of the implementation language

*	Architectural disagreements with Python node software author, notably the architecture of the XML generator 
	(see the :ref:`diff` section)


Used software
-----------------------------------------------

The following open-source libraries were used as Java node software components:

* JAXB RI for XML schema mapping and document output

* Apache Cayenne ORM framework for database access

* MySQL database (any relational database can be used)

* ANTLR generated query parser with slightly modified SQLite syntax

* Oracle Jersey JAX-RS implementation

* Apache Tomcat application server


VAMDC common components
-----------------------------------------------

Following components, developed within the VAMDC project are part of Java VAMDC node software implementation.

* Dictionaries of standard keywords, 
	used in a query;

* Query manipulation library, 
	providing object-oriented view on a query string;

* XSAMS helper library, 
	providing convenience methods for output XML generator implementation;

* Query mapper:
	reference implementation and examples of a mapper from VAMDC VSS2 queries to Cayenne queries


Node-specific components
-----------------------------

In Java node software each node installation requires creating two code blocks:

#. Database mapping classes with Apache Cayenne.
	This task is well described in Cayenne documentation [CAYENNE]_ . Fancy graphical tool is provided.
	
#. Node plugin, 
	responsible for query translation into internal queries 
	and building appropriate XSAMS tree from the database objects
	fetched using mapped queries.

	
This document is dedicated mostly to describe how to implement and deploy a node plugin.

For the rough estimation of the required amount of node-specific code, following numbers should be considered:

*	BASECOL node plugin - total of 1300 lines of code;

*	KIDA node plugin - total of 1070 lines of code;

*	VALD node plugin - total of 600 lines of code;

For all nodes those numbers do not include the autogenerated database model size.

Comparison with the python/django node software
----------------------------------------------------

The paragraph provides a comparison between the Java-Implementation and
the Python/Django node software

Common features
++++++++++++++++++

* Work as a web application behind a web server

* Use object-relational mapping for database access

* Try to minimize the amount of node-specific code

* Node-specific part works as a plugin

.. _diff:

Differencies
++++++++++++++

* The main architectural disagreement 
	between the author of the Java implementation 
	and the authors of Python/Django one is the XML generator.
	
	Java version uses Document Object Model (DOM) mapping of the XML, node plugin needs to build XSAMS blocks
	as trees of related objects.
	
	Python version provides a generator with the defined and limited set of loops and anchors("returnables").
	Node developer needs to study not only the XSAMS documentation, but also to look through 
	a huge and not well documented list of *returnables* keywords 
	to understand where and how to put his data.
	
	
	The use of DOM XML mapping has some advantages and disadvantages:
	
	
	+	On a good side, it gives much more flexibility in document generation.
	
	+	Additional benefit is that it helps to keep the output document error-free,
		thanks to compile-time type checks.
	
	+	XML DOM mapping provided is complete: even if node wishes to put the data in
		a rarely used element of XSAMS,
		it can without the need to output XML blocks as the plain text.
	
	-	On a bad side, task of building a document tree results in a 
		slightly bigger amount of node-specific code.
	
	
	For the task of implementing XSAMS blocks builder, existing builders of KIDA, BASECOL and VALD are
	useful as good examples.
	
	
* Java implementation doesn't (yet) support document streaming, 
	it requires to have a whole document tree to be built in memory
	and then streamed in a response.
	
	Thus increasing memory footprint, it allows to not strictly follow the document generation order,
	i.e. export some species and states, then export processes, while exporting some more species and states.
	
	Also, this way it is easier to verify the document integrity.
	
* Java implementation doesn't provide an import tool from ASCII files into a relational database
	
	Well, there was no need for such a tool. You may use Python one.
	

	
